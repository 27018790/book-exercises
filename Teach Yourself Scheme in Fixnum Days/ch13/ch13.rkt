#lang racket

(add1 (call/cc
       (lambda (k)
         (+ 2 (k 3)))))
(define r #f)
(add1 (call/cc
       (lambda (k)
         (set! r k)
         (+ 2 (k 3)))))
(r 5)
(+ 3 (r 5))

(define (list-product lst)
  (let recur ((lst lst))
    (if (null? lst)
        1
        (* (car lst) (recur (cdr lst))))))
(list-product '(1 2 3))
(list-product '(0 1 2 3))
(define (list-product lst)
  (call/cc
   (lambda (exit)
     (let recur ((lst lst))
       (cond ((null? lst) 1)
             ((zero? (car lst)) (exit 0))
             (else (* (car lst) (recur (cdr lst)))))))))
(list-product '(1 2 3))
(list-product '(0 1 2 3))

(define (same-fringe? tree1 tree2)
  (let loop ((ftree1 (flatten tree1))
             (ftree2 (flatten tree2)))
    (cond ((and (null? ftree1) (null? ftree2)) #t)
          ((or (null? ftree1) (null? ftree2)) #f)
          ((eqv? (car ftree1) (car ftree2)) (loop (cdr ftree1) (cdr ftree2)))
          (else #f))))
(define (flatten tree)
  (cond ((null? tree) '())
        ((pair? (car tree)) (append (flatten (car tree))
                                    (flatten (cdr tree))))
        (else (cons (car tree)
                    (flatten (cdr tree))))))
(same-fringe? '(1 (2 3)) '((1 2) 3))
(same-fringe? '(1 2 3) '(1 (3 2)))
(define (tree->generator tree)
  (let ((caller '*))
    (letrec ((generate-leaves
              (lambda ()
                (let loop ((tree tree))
                  (cond ((null? tree) 'skip)
                        ((pair? tree)
                         (loop (car tree))
                         (loop (cdr tree)))
                        (else (call/cc
                               (lambda (rest-of-tree)
                                 (set! generate-leaves
                                       (lambda ()
                                         (rest-of-tree 'resume)))
                                 (caller tree))))))
                (caller '()))))
      (lambda ()
        (call/cc
         (lambda (k)
           (set! caller k)
           (generate-leaves)))))))
(define (same-fringe? tree1 tree2)
  (let ((gen1 (tree->generator tree1))
        (gen2 (tree->generator tree2)))
    (let loop ()
      (let ((leaf1 (gen1))
            (leaf2 (gen2)))
        (if (eqv? leaf1 leaf2)
            (if (null? leaf1)
                #t
                (loop))
            #f)))))
(same-fringe? '(1 (2 3)) '((1 2) 3))
(same-fringe? '(1 2 3) '(1 (3 2)))

(require "coroutine.rkt")
(define (make-matcher-coroutine tree-cor-1 tree-cor-2)
  (coroutine dont-need-init-arg
             (let loop ()
               (let ((leaf1 (resume tree-cor-1 'get-leaf))
                     (leaf2 (resume tree-cor-2 'get-leaf)))
                 (if (eqv? leaf1 leaf2)
                     (if (null? leaf1)
                         #t
                         (loop))
                     #f)))))
(define (make-leaf-gen-coroutine tree matcher-cor)
  (coroutine dont-need-init-arg
             (let loop ((tree tree))
               (cond ((null? tree) 'skip)
                     ((pair? tree)
                      (loop (car tree))
                      (loop (cdr tree)))
                     (else (resume matcher-cor tree))))
             (resume matcher-cor '())))
(define (same-fringe? tree1 tree2)
  (letrec ((tree-cor-1 (make-leaf-gen-coroutine
                        tree1
                        (lambda (v)
                          (matcher-cor v))))
           (tree-cor-2 (make-leaf-gen-coroutine
                        tree2
                        (lambda (v)
                          (matcher-cor v))))
           (matcher-cor (make-matcher-coroutine
                         (lambda (v)
                           (tree-cor-1 v))
                         (lambda (v)
                           (tree-cor-2 v)))))
    (matcher-cor 'start)))
(same-fringe? '(1 (2 3)) '((1 2) 3))
(same-fringe? '(1 2 3) '(1 (3 2)))
